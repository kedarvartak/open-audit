import { Injectable, OnModuleInit } from '@nestjs/common';
import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';

/**
 * BlockchainService
 * 
 * This service acts as the bridge between the centralized backend (NestJS) and the decentralized blockchain (Ethereum/Anvil).
 * When a user creates a project in the web app, we want to ensure transparency and immutability by recording it on the blockchain.
 * This service handles that "write" operation.
 */
@Injectable()
export class BlockchainService implements OnModuleInit {
    private provider: ethers.JsonRpcProvider;
    private wallet: ethers.Wallet;
    private factoryContract: ethers.Contract;
    private factoryAddress = '0x5FbDB2315678afecb367f032d93F642f64180aa3';

    constructor() {
        this.provider = new ethers.JsonRpcProvider('http://localhost:8545');

        // Initialize the wallet using a pre-funded private key from the local testnet (Anvil Account #0).
        // This wallet will pay the gas fees for the transactions sent by the backend.
        this.wallet = new ethers.Wallet(
            '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
            this.provider,
        );
    }

    /**
     * onModuleInit
     * Lifecycle hook that runs when the module is initialized.
     * We use this to load the Smart Contract ABI dynamically.
     */
    async onModuleInit() {
        // Path to the compiled JSON artifact generated by Hardhat/Foundry in the 'packages/contracts' workspace.
        // This file contains the 'ABI' which tells us what functions the contract has (createProject, etc.).
        const factoryAbiPath = path.resolve(
            __dirname,
            '../../../../../packages/contracts/artifacts/contracts/ProjectFactory.sol/ProjectFactory.json',
        );

        // We check if the ABI file exists to avoid crashing if the contracts haven't been compiled yet.
        if (fs.existsSync(factoryAbiPath)) {
            const factoryArtifact = JSON.parse(fs.readFileSync(factoryAbiPath, 'utf8'));

            // Create the contract instance connecting the Address, the ABI, and the Signer (Wallet).
            this.factoryContract = new ethers.Contract(
                this.factoryAddress,
                factoryArtifact.abi,
                this.wallet,
            );
            console.log('BlockchainService initialized with Factory:', this.factoryAddress);
        } else {
            console.error('Factory ABI not found at:', factoryAbiPath);
            console.error('Make sure to compile the contracts package first!');
        }
    }

    /**
     * createProjectOnChain
     * Triggers the 'createProject' function on the smart contract.
     * 
     * @param title The title of the project to be stored on-chain.
     * @returns The transaction hash of the operation.
     */
    async createProjectOnChain(title: string) {
        // Safety check: ensure contract is initialized
        if (!this.factoryContract) {
            console.warn('BlockchainService: Factory contract not initialized. Skipping on-chain creation.');
            return null;
        }

        try {
            console.log(`BlockchainService: Creating project "${title}" on-chain...`);

            // Send the transaction to the blockchain.
            // This is an asynchronous operation that costs gas (paid by this.wallet).
            const tx = await this.factoryContract.createProject(title);

            // Wait for the transaction to be mined (confirmed) by the network.
            const receipt = await tx.wait();

            console.log(`BlockchainService: Project created on-chain. Tx Hash: ${receipt.hash}`);

            // Return the transaction hash so the caller (ProjectsService) can store it if needed.
            return receipt.hash;
        } catch (error) {
            console.error('Error creating project on chain:', error);
            // We throw the error so the caller knows the blockchain part failed, 
            // allowing them to decide whether to rollback the DB change or just log it.
            throw error;
        }
    }
}
